<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>F Optimization</title> 
<meta http-equiv="Content-Type" content="text/html; charset="utf-8""> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html,2,next,javascript,charset="utf-8" --> 
<meta name="src" content="main.tex"> 
<link rel="stylesheet" type="text/css" href="main.css"> 
<script type="text/javascript" src="scripts/shCore.js"></script> 
<script type="text/javascript" src="scripts/shBrushCpp.js"></script> 
<script type="text/javascript" src="scripts/shBrushJava.js"></script> 
<script type="text/javascript" src="scripts/shBrushPython.js"></script> 
<script type="text/javascript" src="scripts/shBrushBash.js"></script> 
<script type="text/javascript" src="scripts/shBrushXml.js"></script> 
<link href="styles/shCore.css" rel="stylesheet" type="text/css" /> 
<link href="styles/shThemeDefault.css" rel="stylesheet" type="text/css" /> 
<script type="text/javascript"> 
SyntaxHighlighter.all() 
</script> 
 </head><body 
>
<script> 
function f() {  
document.getElementById('main_content_wrap').focus(); 
} 
if (window.addEventListener) { 
window.addEventListener("load", f, false); 
} else if (window.attachEvent) { 
window.attachEvent("onload", f); 
} 
</script> 
<div class="header"> 
<ul class="navbar"> 
<li><a class="logo-small" href="index.html"><img src="images/RedHawk_Logo_ALT_B_121px.png"/></a></li> <li><a href="index.html">Home</a></li> 
<li><a href="gettingstarted/main.html">Getting Started</a></li> 
<li><a class="active" href="main.html">Documentation</a></li> 
<li><a href="download.html">Download</a></li> 
<li><a href="community.html">Community</a></li> 
</ul> 
<div class="pattern right"></div> 
<a id="forkme_banner" href="https://github.com/redhawksdr">View on GitHub</a> 
<noscript><div class ="NoScript">WARNING: JAVASCRIPT is not enabled. JAVASCRIPT is required for viewing code snippets.</div></noscript> 
</div> 
<!-- Custom MAIN CONTENT --> 
<div id="main_content_wrap" tabindex="0" class="outer"> 
<section id="main_content" class="inner"> 
<!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="mainap7.html" >next</a>] [<a 
href="mainap5.html" >prev</a>] [<a 
href="mainap5.html#tailmainap5.html" >prev-tail</a>] [<a 
href="#tailmainap6.html">tail</a>] [<a 
href="main.html#mainap6.html" >up</a>] </p></div>
<h2 class="appendixHead"><span class="titlemark">Appendix&#x00A0;F</span><br /><a 
 id="x32-351000F"></a>Optimization</h2>
<h3 class="sectionHead"><span class="titlemark">F.1   </span> <a 
 id="x32-352000F.1"></a>Introduction</h3>
<!--l. 7--><p class="noindent" >As a system framework, REDHAWK can be affected by any of a large number of possible
ways in which a system can be configured. System optimization is sensitive to the set of
applications that the system is intended to support. However, there are some simple settings
that can apply to a wide set of applications. This chapter focuses on these generalized
settings.
<!--l. 9--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">F.2   </span> <a 
 id="x32-353000F.2"></a>omniORB configuration</h3>
<!--l. 12--><p class="noindent" >The default omniORB configuration is to rely on the loopback interface of the operating system.
While easy to use and manage, the loopback interface is not the fastest default tranport that
omniORB supports. omniORB also supports Linux Domain Sockets, which are essentially named
pipes with the Internet socket API. Linux Domain Sockets are configured through the omniORB
configuration file (/etc/omniORB.cfg).
<!--l. 14--><p class="noindent" >Set the endpoints where the server is listening:
<script type="syntaxhighlighter" class="brush: bash"><![CDATA[
endPoint = giop:tcp:127.0.0.1:
           = giop:tcp:<computer IP address>:
           = giop:unix
]]></script>
<!--l. 22--><p class="noindent" >Set the endpoints that are published in an object&#8217;s <a 
href="mainap7.html#ior">IOR</a>:
<script type="syntaxhighlighter" class="brush: bash"><![CDATA[
endPointPublish = all(addr)
]]></script>
<!--l. 28--><p class="noindent" >After changing these settings, it will be necessary to reset the name and event services. Also, these
                                                                                         
                                                                                         
services&#8217; log files must be deleted, since they would preserve <a 
href="mainap7.html#ior">IOR</a>s that are no longer
valid:
<script type="syntaxhighlighter" class="brush: bash"><![CDATA[
# /etc/init.d/omniEvents stop
# /etc/init.d/omniNames stop
# rm -f /var/lib/omniEvents/*
# rm -f /var/omniNames/*
# /etc/init.d/omniNames start
# /etc/init.d/omniEvents start
]]></script>
<!--l. 39--><p class="noindent" >To verify that Linux Domain Sockets are being used, go to /tmp, where two directories should now
exist: omni-omni and omni-root. These two directories contain the files for the Linux Domain
Sockets. The format for these directories is omni-&#x003C;user&#x003E;, so any user starting an object that hosts
an omniORB servant will have a directory that contains the files for the Linux Domain
Socket. Given that communications are now over what is basically pipes, make sure that
read permissions are open when communicating between objects owned by different
users.
<!--l. 41--><p class="noindent" >This change in the omniORB configuration will have a substantial, measurable improvement in
data transport rates.
<!--l. 43--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">F.3   </span> <a 
 id="x32-354000F.3"></a>Packet transfer size</h3>
<!--l. 45--><p class="noindent" >REDHAWK transfers data using <a 
href="mainap7.html#bulkio">BulkIO</a>, which is basically <a 
href="mainap7.html#rpc">RPC</a>. The size of the data sequence
that is passed on each of these calls will have an effect on the data rate. The size of the transfer is
not controlled by the REDHAWK runtime environment; instead, data producers can pass any
arbitrary length less than <span 
class="ectt-1200">giopMaxMsgSize</span>.
<!--l. 47--><p class="noindent" >Experiments were performed on a system with the specifications shown in  <a 
href="#x32-354000F.3">Table F.3</a>.
<div class="table">
                                                                                         
                                                                                         
<!--l. 55--><p class="noindent" ><hr class="float"><div class="float" 
><table class="float"><tr class="float"><td class="float" 
>
                                                                                         
                                                                                         
<div class="tabular"> <table id="TBL-8" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-8-1g"><col 
id="TBL-8-1"></colgroup><colgroup id="TBL-8-2g"><col 
id="TBL-8-2"></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-8-1-"><td  style="white-space:wrap; text-align:left;" id="TBL-8-1-1"  
class="td11"> <!--l. 58--><p class="noindent" ><span 
class="ecbx-1200">Parameter</span>          </td><td  style="white-space:wrap; text-align:left;" id="TBL-8-1-2"  
class="td11"> <!--l. 58--><p class="noindent" ><span 
class="ecbx-1200">Value</span>                </td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-2-"><td  style="white-space:wrap; text-align:left;" id="TBL-8-2-1"  
class="td11"> <!--l. 59--><p class="noindent" >Number of cores </td><td  style="white-space:wrap; text-align:left;" id="TBL-8-2-2"  
class="td11"> <!--l. 59--><p class="noindent" >8</td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-3-"><td  style="white-space:wrap; text-align:left;" id="TBL-8-3-1"  
class="td11"> <!--l. 60--><p class="noindent" >CPU MHz              </td><td  style="white-space:wrap; text-align:left;" id="TBL-8-3-2"  
class="td11"> <!--l. 60--><p class="noindent" >3.40 GHz               </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-4-"><td  style="white-space:wrap; text-align:left;" id="TBL-8-4-1"  
class="td11"> <!--l. 61--><p class="noindent" >Cache size              </td><td  style="white-space:wrap; text-align:left;" id="TBL-8-4-2"  
class="td11"> <!--l. 61--><p class="noindent" >8192 kB                </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-5-"><td  style="white-space:wrap; text-align:left;" id="TBL-8-5-1"  
class="td11">                   </td></tr></table></div>
                                                                                         
                                                                                         
</td></tr></table></div><hr class="endfloat" />
</div>
<!--l. 69--><p class="noindent" >Figure  <a 
href="#x32-354000F.3">Figure F.3</a> shows the supported data rate in Giga-bytes per second at different transfer
sizes when using the loopback interface (the default setting for omniORB). Note that data rates on
the experiment platform plateau when transfer size approaches approximately 500 kB. Using
higher transfer sizes, data rate does not improve, while latency will increase, since it takes longer
to transfer the larger blocks of data. The specific value at which data rates plateau is
system-specific.
<!--l. 71--><p class="noindent" ><hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x32-354001r1"></a>
                                                                                         
                                                                                         
<!--l. 74--><p class="noindent" ><img 
src="optimization/loopback.jpg" alt="PIC"  
>
<br /> <table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;F.1: </td><td  
class="content">Throughput for <a 
href="mainap7.html#bulkio">BulkIO</a> when using the loopback interface</td></tr></table><!--tex4ht:label?: x32-354001r1 -->
                                                                                         
                                                                                         
<!--l. 76--><p class="noindent" ></td></tr></table></div><hr class="endfigure">
<!--l. 78--><p class="noindent" >Another result derived from the experiment shown in Figure  <a 
href="#x32-354000F.3">Figure F.3</a> is that there is a
substantial impact when the number of component pairs transfering data increases.
<!--l. 80--><p class="noindent" >By following the directions outlined in Section  <a 
href="#x32-353000F.2">Section F.2</a>, it is possible to achieve higher data
rates. Figure  <a 
href="#x32-354000F.3">Figure F.3</a> shows the same experiment as that shown in Figure  <a 
href="#x32-354000F.3">Figure F.3</a>, but with
omniORB configured for Linux Domain Sockets. As seen in Figure  <a 
href="#x32-354000F.3">Figure F.3</a>, sustained data
rates on the computer used in this experiment are roughly four times higher when using Linux
Domain Sockets rather than the loopback interface. Also note that, even when heavily loaded, the
Linux Domain Socket configuration is as fast or faster than the lightly-loaded loopback
configuration.
<!--l. 82--><p class="noindent" ><hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x32-354002r2"></a>
                                                                                         
                                                                                         
<!--l. 85--><p class="noindent" ><img 
src="optimization/linux_domain_sockets.jpg" alt="PIC"  
>
<br /> <table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;F.2: </td><td  
class="content">Throughput for <a 
href="mainap7.html#bulkio">BulkIO</a> when using Linux Domain Sockets</td></tr></table><!--tex4ht:label?: x32-354002r2 -->
                                                                                         
                                                                                         
<!--l. 87--><p class="noindent" ></td></tr></table></div><hr class="endfigure">
<h3 class="sectionHead"><span class="titlemark">F.4   </span> <a 
 id="x32-355000F.4"></a>Messaging latency</h3>
<!--l. 91--><p class="noindent" >Much like <a 
href="mainap7.html#bulkio">BulkIO</a>, messaging is subject to performance issues as the transfer size changes.
Experiments were run where the size of the message was modified and the latency per message was
measured. The average latency was measured for sets of 1000 messages. Figure  <a 
href="#x32-355000F.4">Figure F.4</a> shows
the latency results when using the loopback interface and Figure  <a 
href="#x32-355000F.4">Figure F.4</a> shows the latency
when using Linux Domain Sockets. Latency is a function of the size of the message, where the
measured latency ranges between 40-150 microseconds and 50-160 microseconds for Linux Domain
Sockets and loopback, respectively.
<!--l. 93--><p class="noindent" ><hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x32-355001r3"></a>
                                                                                         
                                                                                         
<!--l. 96--><p class="noindent" ><img 
src="optimization/loop_msg.jpg" alt="PIC"  
>
<br /> <table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;F.3: </td><td  
class="content">Message latency when using the loopback interface</td></tr></table><!--tex4ht:label?: x32-355001r3 -->
                                                                                         
                                                                                         
<!--l. 98--><p class="noindent" ></td></tr></table></div><hr class="endfigure">
<!--l. 100--><p class="noindent" ><hr class="figure"><div class="figure" 
><table class="figure"><tr class="figure"><td class="figure" 
>
                                                                                         
                                                                                         
<a 
 id="x32-355002r4"></a>
                                                                                         
                                                                                         
<!--l. 103--><p class="noindent" ><img 
src="optimization/lds_msg.jpg" alt="PIC"  
>
<br /> <table class="caption" 
><tr style="vertical-align:baseline;" class="caption"><td class="id">Figure&#x00A0;F.4: </td><td  
class="content">Message latency when using Linux Domain Sockets</td></tr></table><!--tex4ht:label?: x32-355002r4 -->
                                                                                         
                                                                                         
<!--l. 105--><p class="noindent" ></td></tr></table></div><hr class="endfigure">
<!--l. 107--><p class="noindent" >Note that in Figures  <a 
href="#x32-355000F.4">Figure F.4</a> and  <a 
href="#x32-355000F.4">Figure F.4</a>, latency is linear as a function of the message
size. Furthermore, the number of concurrent messaging components has no discernible
impact on the message latency. Finally, the difference shown between Linux Domain
Socket performance and loopback interface performance is, while measurable, relatively
small.
                                                                                         
                                                                                         
<!--l. 2--><div class="crosslinks"><p class="noindent">[<a 
href="mainap7.html" >next</a>] [<a 
href="mainap5.html" >prev</a>] [<a 
href="mainap5.html#tailmainap5.html" >prev-tail</a>] [<a 
href="mainap6.html" >front</a>] [<a 
href="main.html#mainap6.html" >up</a>] </p></div>
<!--l. 2--><p class="noindent" ><a 
 id="tailmainap6.html"></a>  
 
<div class=license>  
<hr> 
<a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/80x15.png" /></a><br /><span xmlns:dct="http:// purl.org/dc/terms/" property="dct:title">REDHAWK Documentation</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en_US">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>. 
 
</div> 
</body></html> 
